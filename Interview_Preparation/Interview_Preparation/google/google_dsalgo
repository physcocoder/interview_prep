1)https://www.careercup.com/question?id=5022361498157056 -> 
How would you tell whether a graph has a node with n degree?? 
tell your approach


2) https://www.geeksforgeeks.org/sum-of-bit-differences-among-all-pairs/ ->Sum of bit differences among all pairs
Given an integer array of n integers, find sum of bit differences in all pairs that can be formed 
from array elements. Bit difference of a pair (x, y) is count of different bits at same positions in binary representations of x and y. 
For example, bit difference for 2 and 7 is 2. Binary representation of 2 is 010 and 7 is 111 ( first and last bits differ in two numbers).

Examples :

Input: arr[] = {1, 2}
Output: 4
All pairs in array are (1, 1), (1, 2)
                       (2, 1), (2, 2)
Sum of bit differences = 0 + 2 +
                         2 + 0
                      = 4

Input:  arr[] = {1, 3, 5}
Output: 8
All pairs in array are (1, 1), (1, 3), (1, 5)
                       (3, 1), (3, 3) (3, 5),
                       (5, 1), (5, 3), (5, 5)
Sum of bit differences =  0 + 1 + 1 +
                          1 + 0 + 2 +
                          1 + 2 + 0 
                       = 8

					   
Solution -> def sumBitDifferences(arr,n): 
  
    ans = 0  # Initialize result 
  
    # traverse over all bits 
    for i in range(0, 32): 
      
        # count number of elements with i'th bit set 
        count = 0
        for j in range(0,n): 
            if ( (arr[j] & (1 << i)) ): 
                count+=1
  
        # Add "count * (n - count) * 2" to the answer 
        ans += (count * (n - count) * 2); 
      
    return ans 
  
# Driver prorgram 
arr = [1, 3, 5] 
n = len(arr ) 
print(sumBitDifferences(arr, n)) 


3)https://www.geeksforgeeks.org/google-interview-preparation/ -> Modular Exponentiation (Power in Modular Arithmetic)
Given three numbers x, y and p, compute (xy) % p.

Examples :

Input:  x = 2, y = 3, p = 5
Output: 3
Explanation: 2^3 % 5 = 8 % 5 = 3.

Input:  x = 2, y = 5, p = 13
Output: 6
Explanation: 2^5 % 13 = 32 % 13 = 6.
 
 
Solution - >  # Iterative Python3 program 
# to compute modular power 
  
# Iterative Function to calculate 
# (x^y)%p in O(log y)  
def power(x, y, p) : 
    res = 1     # Initialize result 
  
    # Update x if it is more 
    # than or equal to p 
    x = x % p  
  
    while (y > 0) : 
          
        # If y is odd, multiply 
        # x with result 
        if ((y & 1) == 1) : 
            res = (res * x) % p 
  
        # y must be even now 
        y = y >> 1      # y = y/2 
        x = (x * x) % p 
          
    return res 
      
  
# Driver Code 
  
x = 2; y = 5; p = 13
print("Power is ", power(x, y, p)) 


4) 
https://www.geeksforgeeks.org/google-interview-preparation/ -> 
perm_identity
Sum of bit differences among all pairs
Given an integer array of n integers, find sum of bit differences in all
 pairs that can be formed from array elements. Bit difference of a pair (x, y) is count of
 different bits at same positions in binary representations of x and y. 
For example, bit difference for 2 and 7 is 2. Binary representation of 2 is 010 and 7 is 111 ( first and last bits differ in two numbers).

Examples :

Input: arr[] = {1, 2}
Output: 4
All pairs in array are (1, 1), (1, 2)
                       (2, 1), (2, 2)
Sum of bit differences = 0 + 2 +
                         2 + 0
                      = 4

Input:  arr[] = {1, 3, 5}
Output: 8
All pairs in array are (1, 1), (1, 3), (1, 5)
                       (3, 1), (3, 3) (3, 5),
                       (5, 1), (5, 3), (5, 5)
Sum of bit differences =  0 + 1 + 1 +
                          1 + 0 + 2 +
                          1 + 2 + 0 
                       = 8
					   
					   
Solution -> Solution -> 
def sumBitDifferences(arr,n): 
  
    ans = 0  # Initialize result 
  
    # traverse over all bits 
    for i in range(0, 32): 
      
        # count number of elements with i'th bit set 
        count = 0
        for j in range(0,n): 
            if ( (arr[j] & (1 << i)) ): 
                count+=1
  
        # Add "count * (n - count) * 2" to the answer 
        ans += (count * (n - count) * 2); 
      
    return ans 
  
# Driver prorgram 
arr = [1, 3, 5] 
n = len(arr ) 
print(sumBitDifferences(arr, n)) 

5) https://www.geeksforgeeks.org/inplace-rotate-square-matrix-by-90-degrees/ -> Inplace rotate square matrix by 90 degrees | Set 1
Given an square matrix, turn it by 90 degrees in anti-clockwise direction without using any extra space.

Examples :

Input
 1  2  3
 4  5  6
 7  8  9

Output:
 3  6  9 
 2  5  8 
 1  4  7 

Input:
 1  2  3  4 
 5  6  7  8 
 9 10 11 12 
13 14 15 16 

Output:
 4  8 12 16 
 3  7 11 15 
 2  6 10 14 
 1  5  9 13
 
 
 
 Solution -> # Python3 program to rotate a matrix by 90 degrees 
N = 4
  
# An Inplace function to rotate  
# N x N matrix by 90 degrees in 
# anti-clockwise direction 
def rotateMatrix(mat): 
      
    # Consider all squares one by one 
    for x in range(0, int(N/2)): 
          
        # Consider elements in group    
        # of 4 in current square 
        for y in range(x, N-x-1): 
              
            # store current cell in temp variable 
            temp = mat[x][y] 
  
            # move values from right to top 
            mat[x][y] = mat[y][N-1-x] 
  
            # move values from bottom to right 
            mat[y][N-1-x] = mat[N-1-x][N-1-y] 
  
            # move values from left to bottom 
            mat[N-1-x][N-1-y] = mat[N-1-y][x] 
  
            # assign temp to left 
            mat[N-1-y][x] = temp 
  
  
# Function to pr the matrix 
def displayMatrix( mat ): 
      
    for i in range(0, N): 
          
        for j in range(0, N): 
              
            print (mat[i][j], end = ' ') 
        print ("") 
      
      
  
  
# Driver Code 
mat = [[0 for x in range(N)] for y in range(N)] 
  
# Test case 1 
mat = [ [1, 2, 3, 4 ], 
        [5, 6, 7, 8 ], 
        [9, 10, 11, 12 ], 
        [13, 14, 15, 16 ] ] 
          
''' 
# Test case 2 
mat = [ [1, 2, 3 ], 
        [4, 5, 6 ], 
        [7, 8, 9 ] ] 
  
# Test case 3 
mat = [ [1, 2 ], 
        [4, 5 ] ] 
          
'''
  
rotateMatrix(mat) 
  
# Print rotated matrix 
displayMatrix(mat) 


6)https://www.geeksforgeeks.org/google-interview-preparation/  -> please refer the link as diagram is not loading.


Solution - 


7)https://www.geeksforgeeks.org/meta-strings-check-two-strings-can-become-swap-one-string/ -> Meta Strings (Check if two strings can become same after a swap in one string)
Given two strings, the task is to check whether these strings are meta strings or not. Meta strings are the strings which can be made equal by exactly one swap in any of the strings. Equal string are not considered here as Meta strings.

Examples:

Input : str1 = "geeks" 
        str2 = "keegs"
Output : Yes
By just swapping 'k' and 'g' in any of string, 
both will become same.

Input : str1 = "rsting"
        str2 = "string
Output : No

Input :  str1 = "Converse"
         str2 = "Conserve"
		 
		 
Solution - > # Python program to check if two strings 
# are meta strings 
  
# Returns true if str1 and str2 are meta strings 
def areMetaStrings( str1, str2) : 
    len1 = len(str1) 
    len2 = len(str2) 
        
    # Return false if both are not of equal length 
    if (len1 != len2) : 
        return False
        
    # To store indexes of previously mismatched 
    # characters 
    prev = -1
    curr = -1
        
    count = 0 
    i = 0
    while i < len1 : 
              
        # If current character doesn't match 
        if (str1[i] != str2[i] ) : 
         
        # Count number of unmatched character 
            count = count + 1
        
            # If unmatched are greater than 2, 
            # then return false 
            if (count > 2) : 
                return False
        
            # Store both unmatched characters of 
            # both strings 
            prev = curr 
            curr = i 
              
        i = i + 1
        
    # Check if previous unmatched of string1 
    # is equal to curr unmatched of string2 
    # and also check for curr unmatched character, 
    # if both are same, then return true 
    return (count == 2 and str1[prev] == str2[curr] 
               and str1[curr] == str2[prev]) 
      
# Driver method 
str1 = "converse"
str2 = "conserve"
if ( areMetaStrings(str1,str2) ) : 
     print "Yes" 
else: 
    print "No"
	
8) https://www.geeksforgeeks.org/find-largest-word-dictionary-deleting-characters-given-string/ -> Find largest word in dictionary by deleting some characters of given string
Giving a dictionary and a string ‘str’, find the longest string in dictionary which can be formed by deleting some characters of the given ‘str’.

Examples:

Input : dict = {"ale", "apple", "monkey", "plea"}   
        str = "abpcplea"  
Output : apple 

Input  : dict = {"pintu", "geeksfor", "geeksgeeks", 
                                        " forgeek"} 
         str = "geeksforgeeks"
Output : geeksgeeks


Solution -> // C++ program to find largest word in Dictionary 
// by deleting some characters of given string 
#include <bits/stdc++.h> 
using namespace std; 
  
// Returns true if str1[] is a subsequence of str2[]. 
// m is length of str1 and n is length of str2 
bool isSubSequence(string str1, string str2) 
{ 
    int m = str1.length(), n = str2.length(); 
  
    int j = 0; // For index of str1 (or subsequence 
  
    // Traverse str2 and str1, and compare current 
    // character of str2 with first unmatched char 
    // of str1, if matched then move ahead in str1 
    for (int i=0; i<n&&j<m; i++) 
        if (str1[j] == str2[i]) 
            j++; 
  
    // If all characters of str1 were found in str2 
    return (j==m); 
} 
  
// Returns the longest string in dictionary which is a 
// subsequence of str. 
string findLongestString(vector <string > dict, string str) 
{ 
    string result = ""; 
    int length = 0; 
  
    // Traverse through all words of dictionary 
    for (string word : dict) 
    { 
        // If current word is subsequence of str and is largest 
        // such word so far. 
        if (length < word.length() && isSubSequence(word, str)) 
        { 
            result = word; 
            length = word.length(); 
        } 
    } 
  
    // Return longest string 
    return result; 
} 
  
// Driver program to test above function 
int main() 
{ 
    vector <string > dict = {"ale", "apple", "monkey", "plea"}; 
    string str = "abpcplea" ; 
    cout << findLongestString(dict, str) << endl; 
    return 0; 
} 




9) https://www.geeksforgeeks.org/count-strings-can-formed-using-b-c-given-constraints/ - >Count of strings that can be formed using a, b and c under given constraints
Given a length n, count the number of strings of length n that can be made using ‘a’, ‘b’ and ‘c’ with at-most one ‘b’ and two ‘c’s allowed.

Examples :

Input : n = 3 
Output : 19 
Below strings follow given constraints:
aaa aab aac aba abc aca acb acc baa
bac bca bcc caa cab cac cba cbc cca ccb 

Input  : n = 4
Output : 39


Solution - > # Python 3 program to  
# count number of strings 
# of n characters with 
  
# n is total number of characters. 
# bCount and cCount are counts  
# of 'b' and 'c' respectively. 
def countStr(n, bCount, cCount): 
  
    # Base cases 
    if (bCount < 0 or cCount < 0): 
        return 0
    if (n == 0) : 
        return 1
    if (bCount == 0 and cCount == 0): 
        return 1
  
    # Three cases, we choose, a or b or c 
    # In all three cases n decreases by 1. 
    res = countStr(n - 1, bCount, cCount) 
    res += countStr(n - 1, bCount - 1, cCount) 
    res += countStr(n - 1, bCount, cCount - 1) 
  
    return res 
  
# Driver code 
if __name__ =="__main__": 
    n = 3 # Total number of characters 
    print(countStr(n, 1, 2))
	
10) https://www.geeksforgeeks.org/count-bst-nodes-that-are-in-a-given-range/ -> Given a Binary Search Tree (BST) and a range, count number of nodes that lie in the given range.
Examples:

Input:
        10
      /    \
    5       50
   /       /  \
 1       40   100
Range: [5, 45]

Output:  3
There are three nodes in range, 5, 10 and 40


Solution - > # Python3 program to count BST nodes  
# withing a given range  
  
# Utility function to create new node  
class newNode:  
  
    # Constructor to create a new node  
    def __init__(self, data):  
        self.data = data  
        self.left = None
        self.right = None
  
# Returns count of nodes in BST in  
# range [low, high]  
def getCount(root, low, high): 
      
    # Base case  
    if root == None: 
        return 0
          
    # Special Optional case for improving  
    # efficiency  
    if root.data == high and root.data == low:  
        return 1
  
    # If current node is in range, then  
    # include it in count and recur for  
    # left and right children of it  
    if root.data <= high and root.data >= low:  
        return (1 + getCount(root.left, low, high) + 
                    getCount(root.right, low, high)) 
  
    # If current node is smaller than low,  
    # then recur for right child  
    elif root.data < low:  
        return getCount(root.right, low, high) 
  
    # Else recur for left child  
    else: 
        return getCount(root.left, low, high) 
  
# Driver Code 
if __name__ == '__main__': 
      
    # Let us construct the BST shown in  
    # the above figure  
    root = newNode(10)  
    root.left = newNode(5)  
    root.right = newNode(50)  
    root.left.left = newNode(1)  
    root.right.left = newNode(40) 
    root.right.right = newNode(100) 
      
    # Let us constructed BST shown in above example  
    #    10  
    #    / \  
    # 5  50  
    # /  / \  
    # 1  40 100  
    l = 5
    h = 45
    print("Count of nodes between [", l, ", ", h,"] is ",  
                                    getCount(root, l, h)) 
									
									
									
11)https://www.geeksforgeeks.org/sum-numbers-formed-root-leaf-paths/ - > Sum of all the numbers that are formed from root to leaf paths
Given a binary tree, where every node value is a Digit from 1-9 .Find the sum of all the numbers which are formed from root to leaf paths.
For example consider the following Binary Tree.

                                          6
                                      /      \
                                    3          5
                                  /   \          \
                                 2     5          4  
                                      /   \
                                     7     4
  There are 4 leaves, hence 4 root to leaf paths:
   Path                    Number
  6->3->2                   632
  6->3->5->7               6357
  6->3->5->4               6354
  6->5>4                    654   
Answer = 632 + 6357 + 6354 + 654 = 13997 


Solution -> # Python program to find sum of all paths from root to leaves 
  
# A Binary tree node 
class Node: 
  
    # Constructor to create a new node 
    def __init__(self, data): 
        self.data = data 
        self.left = None
        self.right = None
  
# Returs sums of all root to leaf paths. The first parameter is root 
# of current subtree, the second paramete"r is value of the number 
# formed by nodes from root to this node 
def treePathsSumUtil(root, val): 
  
    # Base Case 
    if root is None: 
        return 0
  
    # Update val 
    val = (val*10 + root.data) 
  
    # If current node is leaf, return the current value of val 
    if root.left is None and root.right is None: 
        return val 
  
    # Recur sum of values for left and right subtree 
    return (treePathsSumUtil(root.left, val) + 
            treePathsSumUtil(root.right, val)) 
  
# A wrapper function over treePathSumUtil() 
def treePathsSum(root): 
      
    # Pass the initial value as 0 as ther is nothing above root 
    return treePathsSumUtil(root, 0) 
  
# Driver function to test above function 
root = Node(6) 
root.left = Node(3) 
root.right = Node(5) 
root.left.left = Node(2) 
root.left.right = Node(5) 
root.right.right = Node(4) 
root.left.right.left = Node(7) 
root.left.right.right = Node(4) 
print "Sum of all paths is", treePathsSum(root) 



12) https://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/ -> Merge two BSTs with limited extra space
Given two Binary Search Trees(BST), print the elements of both BSTs in sorted form. The expected time complexity is O(m+n) where m is the number of nodes in first tree and n is the number of nodes in second tree. Maximum allowed auxiliary space is O(height of the first tree + height of the second tree).

Examples:

First BST 
       3
    /     \
   1       5
Second BST
    4
  /   \
2       6
Output: 1 2 3 4 5 6


First BST 
          8
         / \
        2   10
       /
      1
Second BST 
          5
         / 
        3  
       /
      0
Output: 0 1 2 3 5 8 10 


Solution -> #include<stdio.h> 
#include<stdlib.h> 
  
// Structure of a BST Node 
struct node 
{ 
    int data; 
    struct node *left; 
    struct node *right; 
}; 
  
//.................... START OF STACK RELATED STUFF.................... 
// A stack node 
struct snode 
{ 
    struct node  *t; 
    struct snode *next; 
}; 
  
// Function to add an elemt k to stack 
void push(struct snode **s, struct node *k) 
{ 
    struct snode *tmp = (struct snode *) malloc(sizeof(struct snode)); 
  
    //perform memory check here 
    tmp->t = k; 
    tmp->next = *s; 
    (*s) = tmp; 
} 
  
// Function to pop an element t from stack 
struct node *pop(struct snode **s) 
{ 
    struct  node *t; 
    struct snode *st; 
    st=*s; 
    (*s) = (*s)->next; 
    t = st->t; 
    free(st); 
    return t; 
} 
  
// Fucntion to check whether the stack is empty or not 
int isEmpty(struct snode *s) 
{ 
    if (s == NULL ) 
        return 1; 
  
    return 0; 
} 
//.................... END OF STACK RELATED STUFF.................... 
  
  
/* Utility function to create a new Binary Tree node */
struct node* newNode (int data) 
{ 
    struct node *temp = new struct node; 
    temp->data = data; 
    temp->left = NULL; 
    temp->right = NULL; 
    return temp; 
} 
  
/* A utility function to print Inoder traversal of a Binary Tree */
void inorder(struct node *root) 
{ 
    if (root != NULL) 
    { 
        inorder(root->left); 
        printf("%d ", root->data); 
        inorder(root->right); 
    } 
} 
  
// The function to print data of two BSTs in sorted order 
void  merge(struct node *root1, struct node *root2) 
{ 
    // s1 is stack to hold nodes of first BST 
    struct snode *s1 = NULL; 
  
    // Current node of first BST 
    struct node  *current1 = root1; 
  
    // s2 is stack to hold nodes of second BST 
    struct snode *s2 = NULL; 
  
    // Current node of second BST 
    struct node  *current2 = root2; 
  
    // If first BST is empty, then output is inorder 
    // traversal of second BST 
    if (root1 == NULL) 
    { 
        inorder(root2); 
        return; 
    } 
    // If second BST is empty, then output is inorder 
    // traversal of first BST 
    if (root2 == NULL) 
    { 
        inorder(root1); 
        return ; 
    } 
  
    // Run the loop while there are nodes not yet printed. 
    // The nodes may be in stack(explored, but not printed) 
    // or may be not yet explored 
    while (current1 != NULL || !isEmpty(s1) || 
          current2 != NULL || !isEmpty(s2)) 
    { 
        // Following steps follow iterative Inorder Traversal 
        if (current1 != NULL || current2 != NULL ) 
        { 
            // Reach the leftmost node of both BSTs and push ancestors of 
            // leftmost nodes to stack s1 and s2 respectively 
            if (current1 != NULL) 
            { 
                push(&s1, current1); 
                current1 = current1->left; 
            } 
            if (current2 != NULL) 
            { 
                push(&s2, current2); 
                current2 = current2->left; 
            } 
  
        } 
        else
        { 
            // If we reach a NULL node and either of the stacks is empty, 
            // then one tree is exhausted, ptint the other tree 
            if (isEmpty(s1)) 
            { 
                while (!isEmpty(s2)) 
                { 
                    current2 = pop (&s2); 
                    current2->left = NULL; 
                    inorder(current2); 
                } 
                return ; 
            } 
            if (isEmpty(s2)) 
            { 
                while (!isEmpty(s1)) 
                { 
                    current1 = pop (&s1); 
                    current1->left = NULL; 
                    inorder(current1); 
                } 
                return ; 
            } 
  
            // Pop an element from both stacks and compare the 
            // popped elements 
            current1 = pop(&s1); 
            current2 = pop(&s2); 
  
            // If element of first tree is smaller, then print it 
            // and push the right subtree. If the element is larger, 
            // then we push it back to the corresponding stack. 
            if (current1->data < current2->data) 
            { 
                printf("%d ", current1->data); 
                current1 = current1->right; 
                push(&s2, current2); 
                current2 = NULL; 
            } 
            else
            { 
                printf("%d ", current2->data); 
                current2 = current2->right; 
                push(&s1, current1); 
                current1 = NULL; 
            } 
        } 
    } 
} 
  
/* Driver program to test above functions */
int main() 
{ 
    struct node  *root1 = NULL, *root2 = NULL; 
  
    /* Let us create the following tree as first tree 
            3 
          /  \ 
         1    5 
     */
    root1 = newNode(3); 
    root1->left = newNode(1); 
    root1->right = newNode(5); 
  
    /* Let us create the following tree as second tree 
            4 
          /  \ 
         2    6 
     */
    root2 = newNode(4); 
    root2->left = newNode(2); 
    root2->right = newNode(6); 
  
    // Print sorted nodes of both trees 
    merge(root1, root2); 
  
    return 0; 
} 
Time Complexity: O(m+n)
Auxiliary Space: O(height of the first tree + height of the second tree)



13)https://www.geeksforgeeks.org/find-triplets-array-whose-sum-equal-zero/ -> Find all triplets with zero sum
Given an array of distinct elements. The task is to find triplets in array whose sum is zero.

Examples :

Input : arr[] = {0, -1, 2, -3, 1}
Output : 0 -1 1
         2 -3 1

Input : arr[] = {1, -2, 1, 0, 5}
Output : 1 -2  1


Solution - > filter_none
edit
play_arrow

brightness_4
# A simple Python 3 program  
# to find three elements whose  
# sum is equal to zero 
  
# Prints all triplets in  
# arr[] with 0 sum 
def findTriplets(arr, n): 
  
    found = True
    for i in range(0, n-2): 
      
        for j in range(i+1, n-1): 
          
            for k in range(j+1, n): 
              
                if (arr[i] + arr[j] + arr[k] == 0): 
                    print(arr[i], arr[j], arr[k]) 
                    found = True
      
              
    # If no triplet with 0 sum  
    # found in array 
    if (found == False): 
        print(" not exist ") 
  
# Driver code 
arr = [0, -1, 2, -3, 1] 
n = len(arr) 
findTriplets(arr, n) 
  
Output:
0 -1 1
2 -3 1
Time Complexity : O(n3)
Auxiliary Space : O(1)

 

Method 2 (Hashing : O(n2))
We iterate through every element. For every element arr[i], we find a pair with sum “-arr[i]”. 
This problem reduces to pairs sum and can be solved in O(n) time using hashing.

Run a loop from i=0 to n-2
  Create an empty hash table
  Run inner loop from j=i+1 to n-1
      If -(arr[i] + arr[j]) is present in hash table
         print arr[i], arr[j] and -(arr[i]+arr[j])
      Else
         Insert arr[j] in hash table
		 
14) https://www.geeksforgeeks.org/the-celebrity-problem/ - > The Celebrity Problem
In a party of N people, only one person is known to everyone. 
Such a person may be present in the party, if yes, (s)he doesn’t know anyone in the party.
 We can only ask questions like “does A know B? “. Find the stranger (celebrity) in minimum number of questions.

We can describe the problem input as an array of numbers/characters representing persons in the party.
We also have a hypothetical function HaveAcquaintance(A, B) which returns true if A knows B, false otherwise. How can we solve the problem.
 
Solution -> // Java program to find celebrity using 
// stack data structure 
  
import java.util.Stack; 
  
class GFG  
{ 
    // Person with 2 is celebrity 
    static int MATRIX[][] = { { 0, 0, 1, 0 }, 
                            { 0, 0, 1, 0 }, 
                            { 0, 0, 0, 0 },  
                            { 0, 0, 1, 0 } }; 
  
    // Returns true if a knows  
    // b, false otherwise 
    static boolean knows(int a, int b)  
    { 
        boolean res = (MATRIX[a][b] == 1) ?  
                                     true :  
                                     false; 
        return res; 
    } 
  
    // Returns -1 if celebrity  
    // is not present. If present, 
    // returns id (value from 0 to n-1). 
    static int findCelebrity(int n)  
    { 
        Stack<Integer> st = new Stack<>(); 
        int c; 
  
        // Step 1 :Push everybody 
        // onto stack 
        for (int i = 0; i < n; i++)  
        { 
            st.push(i); 
        } 
  
        while (st.size() > 1)  
        { 
            // Step 2 :Pop off top 
            // two persons from the  
            // stack, discard one  
            // person based on return 
            // status of knows(A, B). 
            int a = st.pop(); 
            int b = st.pop(); 
  
            // Step 3 : Push the  
            // remained person onto stack. 
            if (knows(a, b))  
            { 
                st.push(b); 
            } 
  
            else
                st.push(a); 
        } 
  
        c = st.pop(); 
  
        // Step 5 : Check if the last  
        // person is celebrity or not 
        for (int i = 0; i < n; i++)  
        { 
            // If any person doesn't 
            //  know 'c' or 'a' doesn't  
            // know any person, return -1 
            if (i != c && (knows(c, i) ||  
                          !knows(i, c))) 
                return -1; 
        } 
        return c; 
    } 
  
    // Driver Code 
    public static void main(String[] args)  
    { 
        int n = 4; 
        int result = findCelebrity(n); 
        if (result == -1)  
        { 
            System.out.println("No Celebrity"); 
        }  
        else
            System.out.println("Celebrity ID " +  
                                        result); 
    } 
} 
  
// This code is contributed  
// by Rishabh Mahrsee 

15) https://www.geeksforgeeks.org/optimal-strategy-for-a-game-dp-31/ -> Optimal Strategy for a Game | DP-31
Problem statement: Consider a row of n coins of values v1 . . . vn, where n is even. We play
 a game against an opponent by alternating turns. In each turn, a player selects either the first or 
 last coin from the row, removes it from the row permanently, and receives the value of the coin.
 Determine the maximum possible amount of money we can definitely win if we move first.

Note: The opponent is as clever as the user.

Let us understand the problem with few examples:

    1. 5, 3, 7, 10 : The user collects maximum value as 15(10 + 5)

    2. 8, 15, 3, 7 : The user collects maximum value as 22(7 + 15)



 

Does choosing the best at each move give an optimal solution?

No. In the second example, this is how the game can finish:

1.
…….User chooses 8.
…….Opponent chooses 15.
…….User chooses 7.
…….Opponent chooses 3.
Total value collected by user is 15(8 + 7)
2.
…….User chooses 7.
…….Opponent chooses 8.
…….User chooses 15.
…….Opponent chooses 3.
Total value collected by user is 22(7 + 15)
So if the user follows the second game state, maximum value can be collected although the first move is not the best.

There are two choices:
1. The user chooses the ith coin with value Vi: The opponent either chooses (i+1)th coin or jth coin.
 The opponent intends to choose the coin which leaves the user with minimum value.
i.e. The user can collect the value Vi + min(F(i+2, j), F(i+1, j-1) )
coinGame1

2. The user chooses the jth coin with value Vj: The opponent either chooses ith coin or (j-1)th coin.
 The opponent intends to choose the coin which leaves the user with minimum value.
i.e. The user can collect the value Vj + min(F(i+1, j-1), F(i, j-2) )
coinGame2

Following is recursive solution that is based on above two choices. We take the maximum of two choices.

F(i, j)  represents the maximum value the user can collect from 
         i'th coin to j'th coin.

    F(i, j)  = Max(Vi + min(F(i+2, j), F(i+1, j-1) ), 
                   Vj + min(F(i+1, j-1), F(i, j-2) )) 
Base Cases
    F(i, j)  = Vi           If j == i
    F(i, j)  = max(Vi, Vj)  If j == i+1
	
Solution -> # Python3 program to find out maximum  
# value from a given sequence of coins 
  
# Returns optimal value possible that 
# a player can collect from an array  
# of coins of size n. Note than n  
# must be even  
def optimalStrategyOfGame(arr, n): 
      
    # Create a table to store  
    # solutions of subproblems  
    table = [[0 for i in range(n)] 
                for i in range(n)] 
  
    # Fill table using above recursive  
    # formula. Note that the table is  
    # filled in diagonal fashion  
    # (similar to http:// goo.gl/PQqoS), 
    # from diagonal elements to 
    # table[0][n-1] which is the result.  
    for gap in range(n): 
        for j in range(gap, n): 
            i = j - gap 
              
            # Here x is value of F(i+2, j),  
            # y is F(i+1, j-1) and z is  
            # F(i, j-2) in above recursive  
            # formula  
            x = 0
            if((i + 2) <= j): 
                x = table[i + 2][j] 
            y = 0
            if((i + 1) <= (j - 1)): 
                y = table[i + 1][j - 1] 
            z = 0
            if(i <= (j - 2)): 
                z = table[i][j - 2] 
            table[i][j] = max(arr[i] + min(x, y), 
                              arr[j] + min(y, z)) 
    return table[0][n - 1] 
  
# Driver Code 
arr1 = [ 8, 15, 3, 7 ] 
n = len(arr1) 
print(optimalStrategyOfGame(arr1, n)) 
  
arr2 = [ 2, 2, 2, 2 ] 
n = len(arr2) 
print(optimalStrategyOfGame(arr2, n)) 
  
arr3 = [ 20, 30, 2, 2, 2, 10] 
n = len(arr3) 
print(optimalStrategyOfGame(arr3, n)) 
  
# This code is contibuted  
# by sahilshelangia 

Output:
22
4
42
Exercise Exercise
Your thoughts on the strategy when the user wishes to only win instead of winning with the maximum 
value. Like above problem, number of coins is even.
Can Greedy approach work quite well and give an optimal solution? Will your answer change
if number of coins is odd? Please see Coin game of two corners


16)  https://www.geeksforgeeks.org/given-sorted-dictionary-find-precedence-characters/ -> Given a sorted dictionary of an alien 
language, find order of characters
Given a sorted dictionary (array of words) of an alien language, find order of characters in the language.
Examples:

Input:  words[] = {"baa", "abcd", "abca", "cab", "cad"}
Output: Order of characters is 'b', 'd', 'a', 'c'
Note that words are sorted and in the given language "baa" 
comes before "abcd", therefore 'b' is before 'a' in output.
Similarly we can find other orders.

Input:  words[] = {"caa", "aaa", "aab"}
Output: Order of characters is 'c', 'a', 'b'

The idea is to create a graph of characters and then find topological sorting of the created graph. Following are the detailed steps.

1) Create a graph g with number of vertices equal to the size of alphabet in the given alien 
language. For example, if the alphabet size is 5, then there can be 5 characters in words. Initially there are no edges in graph.

2) Do following for every pair of adjacent words in given sorted array.
…..a) Let the current pair of words be word1 and word2. One by one compare characters of 
both words and find the first mismatching characters.
…..b) Create an edge in g from mismatching character of word1 to that of word2.

3) Print topological sorting of the above created graph.

Following is the implementation of the above algorithm.


Solution -> // A Java program to order of  
// characters in an alien language 
import java.util.*; 
  
// Class to represent a graph 
class Graph 
{ 
  
    // An array representing the graph as an adjacency list 
    private final LinkedList<Integer>[] adjacencyList; 
  
    Graph(int nVertices) 
    { 
        adjacencyList = new LinkedList[nVertices]; 
        for (int vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) 
        { 
            adjacencyList[vertexIndex] = new LinkedList<>(); 
        } 
    } 
  
    // function to add an edge to graph 
    void addEdge(int startVertex, int endVertex) 
    { 
        adjacencyList[startVertex].add(endVertex); 
    } 
  
    private int getNoOfVertices() 
    { 
        return adjacencyList.length; 
    } 
  
    // A recursive function used by topologicalSort 
    private void topologicalSortUtil(int currentVertex, boolean[] visited, 
                                     Stack<Integer> stack) 
    { 
        // Mark the current node as visited. 
        visited[currentVertex] = true; 
  
        // Recur for all the vertices adjacent to this vertex 
        for (int adjacentVertex : adjacencyList[currentVertex]) 
        { 
            if (!visited[adjacentVertex]) 
            { 
                topologicalSortUtil(adjacentVertex, visited, stack); 
            } 
        } 
  
        // Push current vertex to stack which stores result 
        stack.push(currentVertex); 
    } 
  
    // prints a Topological Sort of the complete graph 
    void topologicalSort() 
    { 
        Stack<Integer> stack = new Stack<>(); 
  
        // Mark all the vertices as not visited 
        boolean[] visited = new boolean[getNoOfVertices()]; 
        for (int i = 0; i < getNoOfVertices(); i++) 
        { 
            visited[i] = false; 
        } 
  
        // Call the recursive helper function to store Topological  
        // Sort starting from all vertices one by one 
        for (int i = 0; i < getNoOfVertices(); i++) 
        { 
            if (!visited[i]) 
            { 
                topologicalSortUtil(i, visited, stack); 
            } 
        } 
  
        // Print contents of stack 
        while (!stack.isEmpty()) 
        { 
            System.out.print((char)('a' + stack.pop()) + " "); 
        } 
    } 
} 
  
public class OrderOfCharacters 
{ 
    // This function fidns and prints order 
    // of characer from a sorted array of words. 
    // alpha is number of possible alphabets  
    // starting from 'a'. For simplicity, this 
    // function is written in a way that only 
    // first 'alpha' characters can be there  
    // in words array. For example if alpha 
    //  is 7, then words[] should contain words 
    // having only 'a', 'b','c' 'd', 'e', 'f', 'g' 
    private static void printOrder(String[] words, int alpha) 
    { 
        // Create a graph with 'aplha' edges 
        Graph graph = new Graph(alpha); 
  
        for (int i = 0; i < words.length - 1; i++) 
        { 
            // Take the current two words and find the first mismatching 
            // character 
            String word1 = words[i]; 
            String word2 = words[i+1]; 
            for (int j = 0; j < Math.min(word1.length(), word2.length()); j++) 
            { 
                // If we find a mismatching character, then add an edge 
                // from character of word1 to that of word2 
                if (word1.charAt(j) != word2.charAt(j)) 
                { 
                    graph.addEdge(word1.charAt(j) - 'a', word2.charAt(j)- 'a'); 
                    break; 
                } 
            } 
        } 
  
        // Print topological sort of the above created graph 
        graph.topologicalSort(); 
    } 
  
    // Driver program to test above functions 
    public static void main(String[] args) 
    { 
        String[] words = {"caa", "aaa", "aab"}; 
        printOrder(words, 3); 
    } 
} 
  
//Contributed by Harikrishnan Rajan 

Output:
c a b
Time Complexity: The first step to create a graph takes O(n + alhpa) time where n is number
 of given words and alpha is number of characters in given alphabet. 
 The second step is also topological sorting. Note that there would be
 alpha vertices and at-most (n-1) edges in the graph. The time complexity 
 of topological sorting is O(V+E) which is O(n + aplha) here. So overall time complexity
 is O(n + aplha) + O(n + aplha) which is O(n + aplha).

Exercise:
The above code doesn’t work when the input is not valid. For example {“aba”, “bba”, “aaa”}
 is not valid, because from first two words, we can deduce ‘a’ should appear before ‘b’, but
 from last two words, we can deduce ‘b’ should appear before ‘a’ which is not possible. Extend
 the above program to handle invalid inputs and generate the output as “Not valid”.
 
 
17) https://www.geeksforgeeks.org/check-binary-tree-contains-duplicate-subtrees-size-2/ -> Check if a Binary Tree contains duplicate subtrees of size 2 or more
Given a Binary Tree, check whether the Binary tree contains a duplicate sub-tree of size 2 or more.
Note : Two same leaf nodes are not considered as subtree size of a leaf node is one.

Input :  Binary Tree 
               A
             /    \ 
           B        C
         /   \       \    
        D     E       B     
                     /  \    
                    D    E
Output : Yes


Solution -> // Java program to find if there is a duplicate  
// sub-tree of size 2 or more.  
import java.util.HashSet; 
public class Main {  
  
    static char MARKER = '$'; 
  
    // This function returns empty string if tree  
    // contains a duplicate subtree of size 2 or more.  
    public static String dupSubUtil(Node root, HashSet<String> subtrees)  
    {  
        String s = "";  
    
        // If current node is NULL, return marker  
        if (root == null)  
            return s + MARKER;  
    
        // If left subtree has a duplicate subtree.  
        String lStr = dupSubUtil(root.left,subtrees);  
        if (lStr.equals(s))  
            return s;  
    
        // Do same for right subtree  
        String rStr = dupSubUtil(root.right,subtrees);  
        if (rStr.equals(s))  
            return s;  
    
        // Serialize current subtree  
        s = s + root.data + lStr + rStr;  
    
        // If current subtree already exists in hash  
        // table. [Note that size of a serialized tree  
        // with single node is 3 as it has two marker  
        // nodes.  
        if (s.length() > 3 && subtrees.contains(s))  
            return "";  
    
        subtrees.add(s);  
        return s;  
    }  
  
    //Function to find if the Binary Tree contains duplicate  
    //subtrees of size 2 or more 
    public static String dupSub(Node root) 
    { 
        HashSet<String> subtrees=new HashSet<>(); 
        return dupSubUtil(root,subtrees); 
    } 
  
    public static void main(String args[])  
    { 
        Node root = new Node('A');  
        root.left = new Node('B');  
        root.right = new Node('C');  
        root.left.left = new Node('D');  
        root.left.right = new Node('E');  
        root.right.right = new Node('B');  
        root.right.right.right = new Node('E');  
        root.right.right.left= new Node('D');  
        String str = dupSub(root);  
        if(str.equals("")) 
            System.out.print(" Yes "); 
        else    
            System.out.print(" No ");  
    } 
} 
  
// A binary tree Node has data,  
// pointer to left child  
// and a pointer to right child  
class Node {  
    int data;  
    Node left,right;  
    Node(int data) 
    { 
        this.data=data; 
    } 
}; 

# adding 5 more questions to the existing list 

17)https://www.interviewbit.com/problems/majority-element/ -> Given an array of size n, find the majority element. 
The majority element is the element that appears more than floor(n/2) times.

You may assume that the array is non-empty and the majority element always exist in the array.

Example :

Input : [2, 1, 2]
Return  : 2 which occurs 2 times which is greater than 3/2.


Solution -> not given

18)https://www.interviewbit.com/problems/distinct-subsequences/ -> Given two sequences S, T, count number of 
unique ways in sequence S, to form a subsequence that is identical to the sequence T.

 Subsequence : A subsequence of a string is a new string which is formed from the original string by deleting some 
 (can be none ) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not). 
Example :

S = "rabbbit" 
T = "rabbit"
Return 3. And the formations as follows:

S1= "ra_bbit" 
S2= "rab_bit" 
S3="rabb_it"
"_" marks the removed character.

Solution ->  not given

19)https://www.interviewbit.com/problems/word-break/ ->  Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

For example, given

s = "myinterviewtrainer",
dict = ["trainer", "my", "interview"].
Return 1 ( corresponding to true ) because "myinterviewtrainer" can be segmented as "my interview trainer".

Return 0 / 1 ( 0 for false, 1 for true ) for this problem

Solution -> not given


20)https://www.interviewbit.com/problems/regular-expression-ii/ -> Implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:

int isMatch(const char *s, const char *p)
Some examples:

isMatch("aa","a") → 0
isMatch("aa","aa") → 1
isMatch("aaa","aa") → 0
isMatch("aa", "a*") → 1
isMatch("aa", ".*") → 1
isMatch("ab", ".*") → 1
isMatch("aab", "c*a*b") → 1
Return 0 / 1 ( 0 for false, 1 for true ) for this problem


Solution ->  not given

21)https://www.interviewbit.com/problems/interleaving-strings/ - > Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.

Example,
Given:

s1 = "aabcc",
s2 = "dbbca",
When s3 = "aadbbcbcac", return true.
When s3 = "aadbbbaccc", return false.

Return 0 / 1 ( 0 for false, 1 for true ) for this problem

Solution -> not given





